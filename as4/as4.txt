Author: Shaun Howard, smh150@case.edu
EECS 338 AS4 - Multiple Sleeping Barbers Problem with Monitors - Spring 2016

Initial assumptions about haircuts:
1. every thread is paired with a distinct process id
2. every thread can access its own process id and will be referenced by type (Tina, Judy, Dont
Care)

Initial assumptions about environment of operation:
threads are released by a condition in the queuing order (FIFO)
the maximum line length is 5 people and is denoted as N

It is assumed there are three separate lines (3 queues), namely Tina-Only,
Judy-Only and Dont-Care. Each type of customer will check their own line.
If their line has 5 or more people in it, they will leave.

If a Tina-only customer arrives and the Tina-only line has <5 people and Tina or Judy is
sleeping, they will wake Tina and wait in the Tina-only line.
If a Tina-only customer arrives and the Tina-only line has <5 people and Tina is not sleeping,
they will wait in the Tina-only line.

If a Judy-only customer arrives and the Judy-only line has <5 people and Tina or Judy is
sleeping, they will wake Judy and wait in the Judy-only line.
If a Tina-only customer arrives and the Judy-only line has <5 people and Judy is not sleeping,
they will wait in the Judy-only line.

If a Dont-care customer arrives and the Dont-care-only line has <5 people and Tina or Judy is
sleeping, they will wake Tina and wait in the Dont-care line.
If a Dont-care customer arrives and the Dont-care line has <5 people and Tina is not sleeping,
they will wait in the Dont-care line.

Tina or Judy will stay awake if either has at least one customer (including dont-care customers).
Once no customers are waiting in either their line or dont-care line, that barber will sleep
until they are awoken by a customer.

mod is short for modulo operation.
int is short for integer data type.
cond is short for condition data type
enum is short for enumerated data type
dc is short for don't-care

If there is no waiting thread on a signaled condition variable, the signal is lost as if it
never occurred.

Signaling/signaled process policy: Signaling proceses will continue to execute. Signaled 
process will be blocked until signaling process is blocked or leaves the monitor.


//solution begin

Monitor BarberShop b <- new instance of BarberShop monitor
enum CustType <- {TINA_CUST, JUDY_CUST, DC_CUST}
enum BarbType <- {TINA, JUDY}

Tina {
    int pid <- barber process id
    while true:
        //entry section
	//barber greets next customer or waits for customer to wake them up
	tuple cust_tuple <- b.hello_customer(pid, BarbType.TINA)

	//critical section
	//give haircut to customer using customer's pid and CustType
	b.give_haircut(cust_tuple[0], cust_tuple[1])

	//exit section
        //barber shows customer out
    end while	
}

Judy {
    int pid <- barber process id
    while true:
        //entry section
	//barber greets next customer or waits for customer to wake them up
	tuple cust_tuple <- b.hello_customer(pid, BarbType.JUDY)

	//critical section
	//give haircut to customer using customer's pid and CustType
	b.give_haircut(cust_tuple[0], cust_tuple[1])

	//exit section
	//barber shows customer out
    end while
}

TinaCust {
    int pid <- customer process id

    //entry section
    //check if customer can get in line, otherwise leave
    if b.enter_shop(pid, CustType.TINA_CUST):
        //critical section
        b.get_haircut(CustType.TINA_CUST)
    end if
    
    //exit section
    //customer leaves
    exit customer process
}

JudyCust {
    int pid <- customer process id

    //entry section
    //check if customer can get in line, otherwise leave
    if b.enter_shop(pid, CustType.JUDY_CUST):
        //critical section
        b.get_haircut(CustType.JUDY_CUST)
    end if
    
    //exit section
    //customer leaves
    exit customer process
}

DontCareCust {
    int pid <- customer process id

    //entry section
    //check if customer can get in line, otherwise leave
    if b.enter_shop(pid, CustType.DC_CUST):
        //critical section
        b.get_haircut(CustType.DC_CUST)
    end if
    
    //exit section
    //customer leaves
    exit customer process
}

Monitor BarberShop {
    int N <- 5
    condition ctinaline <- new condition instance
    condition ctinasleeping <- new condition instance
    condition ctinafree <- new condition instance
    condition cjudyline <- new condition instance
    condition cjudysleeping <- new condition instance
    condition cjudyfree <- new condition instance
    condition cdontcareline <- new condition instance
    condition cdontcarefree <- new condition instance

    BlockingFIFOQueue tina_line <- new blocking FIFO Queue of max capacity N
    BlockingFIFOQueue judy_line <- new blocking FIFO Queue of max capacity N
    BlockingFIFOQueue dc_line <- new blocking FIFO Queue of max capacity N    

    //Customer enters the shop to check the line length for their favorite barber (or don't 
    //care option) using this function
	boolean enter_shop(int pid, CustType t):
	    boolean in_line <- false
	    long arrival_time <- the current system time as this point in milliseconds
		tuple cust <- (pid, arrival_time)
		if t == CustType.TINA_CUST:
		    wait(ctinaline)
		    //check and try to get in Tina line
		    in_line <- tina_line.add(cust)
		    signal(ctinaline)
		    if in_line:
			    //signal Tina to wake up
			    signal(ctinasleeping)
		else if t == CustType.JUDY_CUST:
		    wait(cjudyline)
		    //check and try to get in Judy line
		    in_line <- judy_line.add(cust)
		    signal(cjudyline)
		    if in_line:
			    //signal Judy to wake up
			    signal(cjudysleeping)
		else:
		    wait(cdontcareline)
		    //check and try to get in Dont-Care line
		    in_line <- dc_line.add(cust)
		    signal(cdontcareline)
		    if in_line:
			    //signal Tina to wake up
			    signal(ctinasleeping)
		return in_line
 

    //Customer gets a haircut from a barber using this function
    void get_haircut(CustType t):
        if t == CustType.TINA_CUST:
            wait(ctinafree)
            //get haircut
        else if t == CustType.JUDY_CUST:
            wait(cjudyfree)
            //get haircut
        else:
            wait(cdontcarefree)
            //get haircut


    //Tina welcomes customer or sleeps and waits for customer with this function
    //Returns a tuple with the customer's pid and their CustType.
    tuple do_tina_hello():
	    int custid <- 0
	    CustType t <- null
        //wait for access to Tina and DC lines
        wait(ctinaline)
        wait(cdontcareline)

        //sleep if both Tina and DC lines are empty
        if tina_line.isEmpty() and dc_line.isEmpty():
            //signal access back for Tina and DC lines
            signal(ctinaline)
            signal(cdontcareline)
            
            //go to sleep
            wait(ctinasleeping)
            
            //wait for access to Tina and DC lines
            wait(ctinaline)
            wait(cdontcareline)
        
        //either Tina or DC line cannot be empty if Tina was woken up
        if dc_line.isEmpty():
            //do Tina customer if dont-care line is empty
            signal(cdontcareline)
            tina_cust <- tina_line.poll()
            custid <- tina_cust[0]
            signal(ctinaline)
            t <- CustType.TINA_CUST
        else if tina_line.isEmpty():
            //do Dont-care customer if Tina line is empty
            signal(ctinaline)
            dc_cust <- dc_line.poll()
            custid <- dc_cust[0]
            signal(dontcareline)
            t <- CustType.DC_CUST
        else:
            //do either Tina or DC customer depending on who came first (FCFS order)
            tuple tina_cust <- tina_line.peek()
            tuple dc_cust <- dc_line.peek()

	        //compare times of customers, earlier time is smaller
            if tina_cust[1] <= dc_cust[1]:
                signal(cdontcareline)
                //do tina customer if they have equal or earlier time
                tina_cust <- tina_line.poll()
                custid <- tina_cust[0]
                signal(ctinaline)
                t <- CustType.TINA_CUST
            else:
                signal(ctinaline)
                //do dont-care customer if they have earlier time
                dc_cust <- dc_line.poll()
                custid <- dc_cust[0]
                signal(cdontcareline)
                t <- CustType.DC_CUST
	    return (custid, t)


    //Judy welcomes customer or sleeps and waits for customer with this function
    //Returns a tuple with the customer's pid and their CustType.
	tuple do_judy_hello():
	    int custid <- 0
	    CustType t <- null
        //wait for access to Judy and DC lines
        wait(cjudyline)
        wait(cdontcareline)

        //sleep if both Judy and DC lines are empty
        if judy_line.isEmpty() and dc_line.isEmpty():
            //signal access back for Judy and DC lines
            signal(cjudyline)
            signal(cdontcareline)
            
            //go to sleep
            wait(cjudysleeping)
            
            //wait for access to Judy and DC lines
            wait(cjudyline)
            wait(cdontcareline)
        
        //either Judy or DC line cannot be empty if Judy was woken up
        if dc_line.isEmpty():
            //do Judy customer if dont-care line is empty
            signal(cdontcareline)
            judy_cust <- judy_line.poll()
            custid <- judy_cust[0]
            signal(cjudyline)
            t <- CustType.JUDY_CUST
        else if judy_line.isEmpty():
            //do Dont-care customer if Judy line is empty
            signal(cjudyline)
            dc_cust <- dc_line.poll()
            custid <- dc_cust[0]
            signal(dontcareline)
            t <- CustType.DC_CUST
        else:
            //do either Judy or DC customer depending on who came first (FCFS order)
            tuple judy_cust <- judy_line.peek()
            tuple dc_cust <- dc_line.peek()

	        //compare times of customers, earlier time is smaller
            if judy_cust[1] <= dc_cust[1]:
                signal(cdontcareline)
                //do judy customer if they have equal or earlier time
                judy_cust <- judy_line.poll()
                custid <- judy_cust[0]
                signal(cjudyline)
                t <- CustType.JUDY_CUST
            else:
                signal(cjudyline)
                //do dont-care customer if they have earlier time
                dc_cust <- dc_line.poll()
                custid <- dc_cust[0]
                signal(cdontcareline)
                t <- CustType.DC_CUST
	    return (custid, t)


    //Barber greets a new customer or sleeps and waits on a customer with this function
	//Returns a tuple of the customer's pid and their CustType.
	tuple hello_customer(int bpid, BarbType b):
	    tuple cust_tuple <- empty 2-tuple for (int, CustType)
	    if b == TINA:
            //do Tina routine
            cust_tuple <- do_tina_hello()
        else:
            //do Judy routine
            cust_tuple <- do_judy_hello()
        return cust_tuple


	//Barber gives the current customer a haircut using this function
	//Considers Tina-only, Judy-only and Dont-care customers
	void give_haircut(int custid, CustType c):
	    //note that + is the string concatentation operation
	    print "Hello customer " + string(custid) + ", welcome to Tina's Barbershop."
	    if c == CustType.TINA_CUST:
	        signal(ctinafree)
	        //do haircut
	    else if c == CustType.JUDY_CUST:
	        signal(cjudyfree)
	        //do haircut
	    else:
	        signal(cdontcarefree)
	        //do haircut
    
}

BlockingFIFOQueue is a bounded blocking queue backed by an array. It orders elements in first-
in-first-out order. The head of the queue is the element on the queue for the longest amount
of time. The tail of the queue is the element on the queue the shortest amount of time. New
elements are inserted at the tail of the queue. The queue retrieval operations get elements
at the head of the queue. The capacity of the queue cannot be changed after initialization. 
Any attempts to add to a full queue (max capacity reached) lead to the operation blocking.
Attempts to remove an element from an empty queue also will block. Fairness is guaranteed 
by this queue by default. Fairness means that threads access the queue in FIFO order. This 
will help avoid starvation.

boolean add(tuple):
Inserts the specified element at the tail of the queue instance if it is possible to do so
without exceeding the queue's capacity. Returns true upon success or false if queue at capacity.

tuple peek():
Retrieves the head of the queue, without removing it. Returns null if the queue is empty.

tuple poll():
Retrives and removes the head of the queue. Returns null if the queue is empty.

int size():
Returns the number of elements currently in this instance of the queue. Does not return the
capacity of the queue.

boolean isEmpty():
Returns true when the current number of elements in the queue is 0. Returns false if there are
any elements in the queue.
